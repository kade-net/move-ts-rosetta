import { assert } from "console";
import { existsSync, mkdirSync, readFileSync, writeFile, writeFileSync } from "fs";
import path from "path";
import { LEXICON } from "./types";
import { transformConstant, transformFunction, transformStruct } from "./lexicon";
import * as process from "node:process";
import fs from "node:fs";
import {parseModule} from "./translator";


function createContractFolder(contractName: string, modules: Array<string>, parentFolder: string) {

    const contractFolder = path.join(parentFolder, contractName)

    const contractFolderExists = existsSync(contractFolder);

    assert(!contractFolderExists, "Directory already exists");

    mkdirSync(contractFolder);

    const indexFile = path.join(contractFolder, 'index.ts')

    let fileContent = `
// ${contractName.toUpperCase()}
// This Code Was generated automatically, do not modify
// NONCE: ${Date.now()}
${modules.map(module => {
    return `export * from "./${module}"`   
}).join("\n")}`

    writeFileSync(indexFile, fileContent, { encoding: 'utf-8' })

    return contractFolder
}

function initializeDirectoryStructure(moduleName: string, contractFolder: string){
    
    const moduleFolder = path.join(contractFolder, moduleName)

    const moduleExists = existsSync(moduleFolder)

    assert(!moduleExists, "Directory already exists");

    mkdirSync(moduleFolder)

    const indexFile = path.join(moduleFolder, 'index.ts')
    
    writeFileSync(indexFile, '', {
        encoding: 'utf-8'
    })

    const functionsFolder = path.join(moduleFolder, "functions")

    mkdirSync(functionsFolder)

    const functionsIndexFile = path.join(functionsFolder, 'index.ts')

    writeFileSync(functionsIndexFile, '', {
        encoding: 'utf-8'
    })

    const constantsFile = path.join(moduleFolder, 'CONSTANTS.ts')

    writeFileSync(constantsFile, '', {
        encoding: 'utf-8'
    })

    const structsFile = path.join(moduleFolder, 'STRUCTS.ts')

    writeFileSync(structsFile, '', {
        encoding: 'utf-8'
    })

    console.log("MODULE FILE STRUCTURE INITIALIZATION COMPLETE")

    const utilsContent = readFileSync('./utils.ts', {encoding: 'utf-8'})

    const utilsFile = path.join(moduleFolder, 'utils.ts')

    writeFileSync(utilsFile, utilsContent, {
        encoding: 'utf-8'
    })

    return {
        moduleFolder: moduleFolder,
        indexFile,
        functionsFolder: functionsFolder,
        constantsFile,
        structsFile
    }


}

function createModuleIndexFile(lexicon: LEXICON) {
    let line = "// DO NOT MODIFY, THIS FILE WAS AUTOGENERATED\n"

    line += `import * as functions from "./functions"\n`
    line += `import * as constants from "./CONSTANTS"\n`
    line += `import * as structs from "./STRUCTS"\n`

    line += `

export const ${lexicon.module} = {
    functions,
    constants,
    structs
}
    `

    return line
}

function parseContract(contractFolder: string) {
    const targetDir = path.join(contractFolder)

    const moveTomlFileContent = readFileSync(path.join(targetDir, 'Move.toml'), {encoding: 'utf-8'})
    let name = moveTomlFileContent.match(/(name)\s+=\s+(\S)+/gm)?.at(0)?.replace("name =", "")?.trim()?.replaceAll("\"", "")

    let moduleFiles = fs.readdirSync(path.join(targetDir, 'sources')).filter(f=>fs.statSync(path.join(targetDir, 'sources', f)).isFile() && f.endsWith('.move'))
    const modules = moduleFiles.map(module => module.replace(".move", ""))

    return {
        name,
        modules,
        moduleFiles: moduleFiles.map(module => path.join(targetDir, 'sources', module))
    }
}

function createLexicons(args: ReturnType<typeof parseContract>){
    return args.moduleFiles.map(moduleFile => parseModule(moduleFile))
}


function transpileModule(parentFolder: string, basePath: string, lexicon: LEXICON){


    const { constantsFile, functionsFolder, indexFile, moduleFolder, structsFile } = initializeDirectoryStructure(lexicon.module, parentFolder)

    const constantsData = lexicon.constants.map(transformConstant).join("\n")

    writeFileSync(constantsFile, constantsData, {
        encoding: 'utf-8'
    })

    let structsData = `import { queryFn } from "./utils"\n\n`
    structsData += lexicon.structs.map((s)=>transformStruct(s, lexicon.structs, basePath)).join("\n")

    writeFileSync(structsFile, structsData, {
        encoding: 'utf-8'
    })

    let functionsIndexContent = "";

    for (const fun of lexicon.functions) {

        if(fun.name.trim().startsWith('init_module') || fun.name.trim().startsWith('test') || fun.parameters.length == 0) {
            continue;
        }
        const funcFilename = path.join(functionsFolder, `${fun.name}.ts`)

        const content = transformFunction(fun, basePath, lexicon.structs)

        writeFileSync(funcFilename, content, {
            encoding: 'utf-8'
        })

        functionsIndexContent += `\n export * as ${fun.name} from "./${fun.name}"`
    }
    
    writeFileSync(path.join(functionsFolder,'index.ts'), functionsIndexContent)

    const moduleIndexContent = createModuleIndexFile(lexicon)

    writeFileSync(path.join(moduleFolder, "index.ts"), moduleIndexContent)
    

}

function main(targetDir: string, contractDir: string, contractAddress: string) {
    const contract = parseContract(contractDir)
    const moduleLexicons = createLexicons(contract)

    const contractFolder = createContractFolder(contract.name!, contract.modules, targetDir)

    for (const lexicon of moduleLexicons) {
        const BASE_PATH = `${contractAddress}::${contract.name}::${lexicon.module}::`
        transpileModule(contractFolder,BASE_PATH, lexicon)
    }
}


export function run(_targetFolder: string, _sourceFolder: string, contractAddress: string){

    const targetFolder = path.join(process.cwd(), _targetFolder);
    const sourceFolder = path.join(process.cwd(), _sourceFolder);
    main(targetFolder, sourceFolder, contractAddress)
    console.log("MODULE CREATED SUCCESSFUL ðŸŽ‰")
}
